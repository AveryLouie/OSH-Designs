/*
LED driver software for LDP-6416
Written by Avery Louie for Ryan Hurst
*/


//defines used on old versions of code, still useful for wiring reference
//all these pins live on PORT D, D0-3
#define RD  0
#define GR  1
#define  S  2
#define EN  3


//all these pins live on PORT B 
#define  A  8
#define  B  9
#define  C 10
#define  D 11

#define  L 13


//the "image" for the static test using send_line and noob_line
byte bmp[16][16]={
  
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55},
  {0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA},
  {0x00,0xff,0x55,0xAA,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0xFF,0x00,0xFF,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x70,0x50,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
  {0x00,0xff,0x55,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  
  };
  
//the "image" for the wise_line function.  Can even scroll!
byte img_G[64][2]={
{0xAA,0xFF},
{0xAA,0xFF},
{0xAA,0xF1},
{0xAA,0x55},
{0xFF,0x55},
{0xFF,0x55},
{0xFF,0xFF},
{0xFF,0xFF},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xFF,0xFF},
{0xFF,0xFF},
{0x00,0x08},
{0x00,0x00},
{0xFF,0xFF},
{0xFF,0xFF},
{0xAA,0x55},
{0xAA,0x55},
{0x55,0x55},
{0x00,0x55},
{0x01,0x55},
{0x03,0x55},
{0x07,0x55},
{0x0F,0x55},
{0x3F,0x55},
{0x6F,0x55},
{0x7F,0x55},
{0xFF,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0xfe}
};
//red image for wise_line
byte img_R[64][2]={
{0x07,0x55},
{0x0F,0x55},
{0x3F,0x55},
{0x6F,0x55},
{0x7F,0x55},
{0xFF,0x55},
{0xAA,0x55},
{0xAA,0xFF},
{0xAA,0xFF},
{0xAA,0xF1},
{0xAA,0x55},
{0xFF,0x55},
{0xFF,0x55},
{0xFF,0xFF},
{0xFF,0xFF},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xFF,0xFF},
{0xFF,0xFF},
{0x00,0x08},
{0x00,0x00},
{0xFF,0xFF},
{0xFF,0xFF},
{0xAA,0x55},
{0xAA,0x55},
{0x55,0x55},
{0x00,0x55},
{0x01,0x55},
{0x03,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x55},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0x50},
{0xAA,0xfe}
};


void setup(){
  //setup all pins interfacing with the panel to be outputs
  pinMode(EN, OUTPUT);
  pinMode(RD, OUTPUT);
  pinMode(GR, OUTPUT);
  pinMode(A,  OUTPUT);
  pinMode(B,  OUTPUT);
  pinMode(C,  OUTPUT);
  pinMode(D,  OUTPUT);
  pinMode(L,  OUTPUT);
  pinMode(S,  OUTPUT);
  
  //default state of S is high
  digitalWrite(S,HIGH);
}

void loop(){
  
  //lin, leaf, ud and rd are different refresh patterns.  Try them out!
  int leaf[16]={0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15};
  int ud[16]  ={0,15,1,14,2,13,3,12,4,11,5,10,6,9,7,8};
  int rd[16]  ={3,1,6,13,7,14,4,10,5,11,0,12,2,8,15,9};
  int lin[16] ={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
  
  //top    0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80
  //bottom 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
  byte xd[16] = {0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
  
  unsigned long oldtime=millis();
  byte shift=0;
  
  //uncomment this part if you want to see noob_line run
  /*
  analogWrite(EN,1);
  while(1){
    for(int i=0 ; i<16 ; i++)
    {
      noob_line(rd[i]);
      PORTB=rd[i];
    }
  }
  */
    
  //uncomment this part to see send_line run
  /*
  analogWrite(EN,1);
  while(1){
    for(int i=0 ; i<16 ; i++)
    {
      send_line(rd[i]);
      PORTB=rd[i];
    }
  }
  */
  
  //comment this and uncomment the other functions to change to the other functions.  Use this to see scrolling images.
  
  while(1){
    if(millis()-oldtime>70)  //change the value of millis()-oldtime>70 to something other than 70 to make the scroll faster or slower
    {
      oldtime=millis();
      shift++;
        if (shift>64){      //images are 64 bits long, so if you get to the end of an image you need to reset the shift amount to 0. playing with how this works, you could do bouncing images etc.
          shift=0;
        }
    }
    
    for(int i=0; i<16; i++)
    {
      PORTD|=0b00001000;        //toggle en low
      wise_line(xd[i],shift);   //to change it to no scroll, replace shift with 0
      PORTD&=0b11110111;        //toggle en high
      PORTB=i;
      delayMicroseconds(500);     //light the leds for 500us before drawing the next line.  longer can make it brighter, but adds flicker
    }
    
  }
  
}



/*
The smart way to do things.
*/
void wise_line(byte line,byte shift)
{
  for(int i=shift; i<64; i++) //starting at the shift value, print the image
  {
    //set portD to be the data you want to clock in
    //lets break this down
    //img_G[i][line>>7] gets an 8-bit value from the green image.  the first bit of line tells you if it is from the top or the bottom
    //this value is masked with whatever part of the line we want.  for example, if line is 0b100000011, we want the 3rd line.  to get this mask just shift 1<<3
    //so img_G[i][line>>7]&(0b1<<(line&0b111) masks the 8-bit value with the actual line we want
    //Once we have that, we need to shift down to the bottom of the byte
    //finally, for green only, we shift it up one, since the last two bytes of portd are 0bGR, where G is the green bit and R is the red bit
    PORTD =0b11111000 | (((img_G[i][line>>7]&(0b1<<(line&0b111)))>>(line&0b111))<<1) | ((img_R[i][line>>7]&(0b1<<(line&0b111)))>>(line&0b111));
    PORTD|=0b00000100;//clock in the actual data by raising the S line.
  }
  for(int i=0; i<shift; i++)
  {
    PORTD =0b11111000 | (((img_G[i][line>>7]&(0b1<<(line&0b111)))>>(line&0b111))<<1) | ((img_R[i][line>>7]&(0b1<<(line&0b111)))>>(line&0b111));
    PORTD|=0b00000100;
  }
  digitalWrite(L,HIGH);
  digitalWrite(L,LOW);
}

void noob_line(int line){
  
  for(int k=0; k<16; k++)
  {
      for(int j=3; j>=0; j--)
      {
        /*here is some more bit-mathgic.  not very pretty but this function takes the nth bit of the map on a line
        then it masks it to get the two bits you want, and shifts those down to the right position to write them to the pin
        */
        digitalWrite(RD,bmp[line][k]&(0b1<<j*2)>>j*2);
        digitalWrite(GR,bmp[line][k]&(0b10<<j*2)>>j*2);
        digitalWrite(S,LOW);
        digitalWrite(S,HIGH);
      }
    }
    
  digitalWrite(L,HIGH);
  digitalWrite(L,LOW);
}
  
void send_line(byte line){
  
  for(int k=0; k<16; k++)
  {
    {
      for(int j=3; j>=0; j--)
      {
        //similar to noob_line, only it masks for two bits at the same time, not one
        PORTD =0b11111000 | ((bmp[line][k] & (0b11<<j*2))>>j*2);
        PORTD|=0b00000100;
      }
    }
    
  }
  digitalWrite(L,HIGH);
  digitalWrite(L,LOW);
}
